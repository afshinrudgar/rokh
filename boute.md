[رُخ](https://github.com/afshinrodgar/rokh) در گیت‌هاب

<!--
یکی از مسائل مطرح در حوزه پردازش تصویر، تشخیص چهره انسان‌هاست. ایجاد یک سیستم تشخیص چهره قدرتمند می‌تواند در پروژه‌های مرتبط با تجستجوگر تصاویر، تعامل انسان و کامپیوتر، دوربین‌های عکاسی و بسیاری از موارد دیگر به کار برده شود. مسئله تشخیص چهره یکی از قدیمی‌ترین مسائل بینایی کامپیوتری بوده است که اکنون یکی از مسائل حل شده در بینایی کامپیوتری به حساب می‌آید. محصولات تجاری مختلفی مثل دوربین‌های عکاسی، نرم‌افزارهای مدیریت عکس و شبکه‌های اجتماعی وجود دارند که از این سیستم استفاده می‌کنند.

در تشخیص چهره شما عکسی را دریافت می‌کنید و در این عکس باید محدوده‌ی چهره‌های انسان که می‌بینید را توسط یک مستطیل مشخص کنید (مانند شکل).

در این پروژه از شما خواسته می‌شود که چالش‌های موجود در این زمینه را بررسی کنید. همچنین راه حل‌ها و روش‌های مختلف برای این مسئله را بررسی کنید و یکی را پیاده سازی کنید.

![تصویر نمونه](http://upload.wikimedia.org/wikipedia/commons/e/ef/Face_detection.jpg)
![تصویر نمونه](http://cdn.itproportal.com/photos/Face-Detection-7_original.jpg)
-->

# مقدمه
اولین قدم در فرایند پردازش چهره‌، تشخیص چهره است.
هدف از تشخیص چهره پاسخ به این سوال خواهد بود که آیا در یک عکس چهره -و یا چهره‌هایی- وجود دارد یا نه؟ و اگر بله مکان هر کدام از چهره‌ -و یا چهره‌ها- کجاست؟

از موارد زیر می‌توان به عنوان چالش‌های پیش‌رو در زمینه‌ی تشخیص چهره‌ نام برد:

+ **زاویه چهره**[^1]. این‌که دوربین از کدام زاویه (تمام‌رخ، نیم‌رخ و ...) از چهره عکس گرفته باشد می‌توان فاکتور مهمی در درجه‌ی سختی تشخیص چهره محسوب گردد.
+ **وجود یا عدم وجود اجزای مختلف صورت**. اجزای مختلف صورت از جمله محاسن، سبیل و ... می‌توانند در چهره‌ی فرد موجود باشند یا نباشند. از طرفی دیگر تفاوت‌های زیادی بین شکل‌های مختلف این اجزا وجود دارد.
+ **حالات چهره**. نمای صورت در حالات مختلف چهره (لبخند، خنده، گریه و ...) متفاوت خواهد بود.
+ **پوشش**. ممکن است قسمتی از چهره بخاطر *زاویه چهره* و یا قرارگیری پشت اشیاء دیگر قابل مشاهده نباشد.
+ **زاویه عکس**[^2]. اشیاء مختلف با قرارگیری در زاویه‌های مختلف نسبت به صفحه مماس اشکال خاصی به خود می‌گیرند.
+ **شرایط عکاسی**. فاکتور‌های مختلف محیطی نظیر شرایط نوری و مشخصات دوربین عکاسی از جمله لنز‌ می‌توانند تاثیر زیادی در پروسه تشخیص چهره داشته باشند.

<img src="http://upload.wikimedia.org/wikipedia/en/2/24/Lenna.png" style="width:512px;-webkit-border-radius:20px;-moz-border-radius: 20px;border-radius: 20px;  box-shadow: 0px 0px 7px 1px #202020;-webkit-box-shadow: 0px 0px 7px 1px #202020;-moz-box-shadow: 0px 0px 7px 1px #202020;" alt="Lenna" >

<p align="center">
شکل شماره ۱
</p>

در ادبیات تشخیص چهره، مفهومی مرتبط وجود دارد که از آن به عنوان *مکان‌یابی چهره*[^3] یاد می‌کنیم. خواننده محترم باید این نکته را در نظر داشته باشد که هدف از *مکان‌یابی چهره* درست همانند *تشخیص چهره* هست اما تفاوت اندکی موجود خواهد بود و آن این که در *مکان‌یابی چهره* تصویر موجود فقط شامل یک چهره در نظر گرفته می‌شود.
یکی از روش‌های مرسوم در زمینه تشخیص اشیاء در نظر گرفتن قابی[^4] کوچک روی تصویر اصلی و تشخیص این خواهد بود که آیا شیء مورد نظر در آن پنجره وجود دارد یا نه؟ پس اگر از این روش استفاده شود باید در جستجوی الگوریتمی بود تا توانایی تشخیص وجود یا عدم وجود چهره در یک قاب کوچک، متشکل از چند صد پیکسل داشته باشد.
در این دیدگاه تشخیص چهره را می‌توان به صورت مساله‌ی دسته بندی نیز در نظر گرفت. به این صورت که عامل هوش مصنوعی باید قاب‌های مختلف موجود در تصویر را در دو گروه *چهره* و *غیرچهره* در نظر گرفت.

المان‌های مختلفی را می‌توان در ارزیابی یک سیستم تشخیص چهره مؤثر دانست مانند زمان یادگیری، زمان اجرا، تعداد مثال‌های مورد نیاز برای یادگیری و نسبت بین میزان تشخیص[^10] و خطای منفی[^11].
*میزان تشخیص* را می‌توان به نسبت تعداد چهره‌های درست تشخیص داده شده توسط عامل هوش مصنوعی به تعداد چهره‌های تشخیص داده شده توسط انسان تعریف کرد.
در صورتی قابی توسط عامل تشخیص داده شده است به عنوان چهره در نظر گرفته می‌شود که قاب مورد نظر بیشتر از میزان خاصی از چهره‌ی فرد را پوشش دهد.
از طرف دیگر *خطای منفی* زمانی رخ می‌دهد که عامل در تشخیص چهره ناموفق باشد که این خود ریشه در پایین بودن *میزان تشخیص* خواهد بود. در مقابل *خطای منفی* مفهوم دیگری به نام *خطای مثبت*[^12] وجود دارد که وقتی قابی به عنوان چهره از طرف عامل هوش‌ مصنوعی معرفی می‌شود اما عامل انسانی تایید نمی‌کند، رخ می‌دهد.

$$detection\ rate= \frac{correctly\ detected}{determined\ by\ human}$$

نکته‌ی مهم در رابطه با *خطای منفی* یا *خطای مثبت* این است که هر چه قوانین پیاده‌سازی شده سخت‌تر و به واسطه‌ی آن رفتار عامل سخت‌گیرانه تر باشد *خطای منفی* بالاتر و *خطای مثبت* پایین‌تر خواهد بود و بالعکس.
<!--
پس برای این‌که وجود روش *مکان‌یابی چهره* بی‌معنی جلوه نکند این‌گونه در نظر بگیرید که که در تشخیص چهره پنجره‌های ممکن روی تصویر اعمال می‌شود و با استفاده از روش‌های *مکان‌یابی چهره* می‌توان تشخیص داد که در آن ناحیه چهره‌ای موجود است یا خیر؟ مساله‌ی دیگری که وجود دارد *تشخیص اجزای صورت*[^5] خواهد بود که هدف از آن به‌دست آوردن جوابی برای وجود یا عدم وجود و مکان اجزای مختلف صورت از جمله چشم‌ها، لب‌ و ... خواهد بود.
-->

## روش‌های موجود
روش‌های موجود در تشخیص چهره را می‌توان به چهار گروه مختلف تقسیم کرد:

+ **روش‌های دانش‌ محور[^6]**
+ **روش‌های جزئیات محور[^7]**
+ **روش‌های الگو محور[^8]**
+ **روش‌های ظاهر محور[^9]**

### روش‌های دانش محور
مشکل اساسی در این روش پیاده‌سازی دانش انسانی خواهد بود. از طرف دیگر عمل‌کرد این نوع عامل‌ها در تشخیص چهره بسیار خوب بوده است.

یکی از استراتژی‌های جالب توجه در این روش استفاده از الگوریتم‌های ابتکاری خواهد بود. بدین صورت که ابتدا با اعمال بعضی قوانین ساده‌تر بر روی تصویر با کیفیت پایین‌تر به راحتی تعداد زیادی از قاب‌ها را حذف کرده و در مراحل بعدی با اعمال قوانین سخت‌گیرانه‌تر قاب‌های باقی‌مانده را فیلتر کرد. در پایان هر کدام از قاب‌ها که همه‌ی قوانین را پشت سر گذاشته است به عنوان چهره تشخیص داده می‌شود.

<img id="pic2" src="http://cesaserver.iust.ac.ir:7000/public.php?service=files&t=84640ecf3af587a24c981dd955c3b232&download" style="width:250px;-webkit-border-radius:20px;-moz-border-radius: 20px;border-radius: 20px;  box-shadow: 0px 0px 7px 1px #202020;-webkit-box-shadow: 0px 0px 7px 1px #202020;-moz-box-shadow: 0px 0px 7px 1px #202020;" alt="Knowledge-based Methods" >

<p align="center">
شکل شماره ۲
</p>

یک تصویر مورد استفاده در روش‌های بالا-به-پایین دانش محور تولید شده بر اساس دانش انسانی درباره خصوصیات چهره انسان.بر گرفته از **[4]**

### روش‌های جزئیات محور
برعکس روش دانش‌ محور محققان در این روش به دنبال یافتن اجزای مختلف صورت برای تشخیص چهره خواهند بود.
فرض بنیادین در این روش این مشاهده بوده که انسان بدون دشواری در زوایای مختلف چهره و شرایط نوری متفاوت می‌تواند به‌راحتی چهره را تشخیص دهد.
اجزای مختلف چهره مانند ابروها، چشم‌ها، بینی و دهان براحتی توسط آشکارساز لبه استخراج می‌شوند. بر اساس اجزای استخراج شده مدلی آماری از رابطه‌ی اجزای صورت با هم ساخته می‌شود تا در تأیید وجود چهره مورد‌ استفاده قرار گیرد.

یکی از مشکلات این نوع روش‌ها این است که تصویر اجزای مختلف صورت بخاطر شرایط نوری نامناسب، نویز و یا پوشش خراب شود. وجود این مشکل احتمال بروز این مسأله که مرز‌های اجزای صورت از دست برود و یا بخاطر ایجاد سایه‌های زیاد الگوریتم بی‌فایده گردد را نیز افزایش می‌دهد.

### روش‌های الگو محور
در روش الگو محور الگوی استانداردی از چهره‌ی انسان به صورت دستی و یا به صورت تابعی ریاضی از پیش تعیین گردد.با دریافت تصویر ورودی، همبستگی میان تصویر در مرزهای صورت، چشم‌ها و.. با الگو بدست می‌آید. تصمیم نهایی در خصوص تشخیص تصویر بر اساس مقدار همبستگی خواهد بود.

اگر چه این روش به راحتی قابلیت پیاده سازی دارد اما از آنجایی که در مصاف با تصاویر با مقیاس مختلف‌، زاویه چهره و اشکال متفاوت باز می‌ماند گزینه‌ی خوبی برای استفاده در مساله‌هایی که تصاویر چهره در آن در شرایط مختلف وجود دارد نخواهد بود.

<img src="http://cesaserver.iust.ac.ir:7000/public.php?service=files&t=36e20a132b37cbfe71a34213d32ee2bd&download" style="width:350px;-webkit-border-radius:20px;-moz-border-radius: 20px;border-radius: 20px;  box-shadow: 0px 0px 7px 1px #202020;-webkit-box-shadow: 0px 0px 7px 1px #202020;-moz-box-shadow: 0px 0px 7px 1px #202020;" alt="Template-based Methods">

<p align="center">
شکل شماره ۳
</p>
الگوی نسبی تولید شده جهت تشخیص چهره (بر گرفته از **[5]**)

### روش‌های ظاهر محور
بر خلاف روش الگو محور که در آن الگوی مورد استفاده توسط گروهی متخصص تولید می‌گردد در روش ظاهر محور این الگو از آموزش عامل هوش مصنوعی بوسیله‌ی تعدادی مثال‌ از تصاویر چهره حاصل می‌شود. به طور معمول روش‌های ظاهر محور بر اساس آنالیز آماری و یادگیری ماشین استوار است. در همین حال از کاهش کیفیت تصاویر نیز در جهت بهبود عملکرد محاسباتی استفاده می‌شود.

# کارهای مرتبط
وایولا و جونز در **[2]** روشی برای حل مسأله تشخیص اشیاء مبتنی بر یادگیری ماشینی را معرفی کرده‌اند که قادر به پردازش سریع تصاویر با میزان تشخیص بالا خواهد بود.

روش معرفی شده که به نوعی نماینده‌ی روش‌های ظاهرمحور محسوب می‌شود از سه عنصر کلیدی استفاده می‌کند:

+ **انتگرال تصویر**[^13] که توانایی محاسبه سریع مجموع مقادیر پیکسل‌های موجود در یک قاب مستطیل شکل را به ما می‌دهد.
+ **آدابوست**[^14] که ما را قادر به تنظیم پارامتر‌های مختلف، نوع و تعداد *مشخصه‌های هار*[^18] مورد استفاده در *الگوریتم‌های کلاس‌بندی*[^17] موجود در مدل آبشاری می‌کند تا بتوان با استفاده از کمترین تعداد از *مشخصه‌های هار* و در نتیجه محاسبه‌ی کمتر به بیشترین میزان تشخیص رسید.
+ **روش آبشاری در کلاس‌بندی اشیا**.


## انتگرال تصویر **[9]**
*ماتریس مجموع محیطی*[^15] ساختمان داده و الگوریتمی برای محاسبه‌ی سریع و دقیق زیرمجموعه‌ای از یک ماتریس (برای مثال یک تصویر) که به شکل مستطیلی ظاهر می‌شود، است.

در ادبیات پردازش تصویر از این الگوریتم به عنوان *انتگرال تصویر* نیز یاد می‌شود.
همان‌طور که از نام تکنیک پیداست مقدار درایه‌ی *(x, y)* *ماتریس مجموع محیطی* برابرست با مجموع همه‌ی مقادیر بالا و چپ درایه‌ی *(x, y)* ماتریس اصلی.

$$I(x,y)=\sum_{{x}'<x{y}'<y}{i({x}',{y}')}$$

علاوه بر این *ماتریس مجموع محیطی* به راحتی و با تکیه به این اصل که مقدار درایه‌ی *(x,y)* آن از طریق فرمول زیر بدست می‌آید، قابل محاسبه است.

$$I(x,y)=i(x,y) - I(x-1,y) + I(x,y-1) - I(x-1,y-1)$$

بدین ترتیب وقتی *ماتریس مجموع محیطی* محاسبه شد، مقداردهی به هر زیر مجموعه‌ی مستطیل شکلی به‌سادگی و در زمان ثابت قابل انجام می‌باشد. برای محاسبه از فرمول زیر می‌توان استفاده کرد.

اگر فرض کنیم $A=(x_0, y_1)$,$B=(x_1, y_1)$,$C=(x_1, y_0)$,$D=(x_0, y_0)$  باشند، آنگاه:

$$\sum_{x_0<{x}'<x_1, y_0<{y}'<y_1}{i({x}',{y}')}={I(C)+I(A)-I(B)-I(D)}$$

<img src="http://upload.wikimedia.org/wikipedia/commons/e/ee/Prm_VJ_fig3_computeRectangleWithAlpha.png" style="width:250px;-webkit-border-radius:20px;-moz-border-radius: 20px;border-radius: 20px;  box-shadow: 0px 0px 7px 1px #202020;-webkit-box-shadow: 0px 0px 7px 1px #202020;-moz-box-shadow: 0px 0px 7px 1px #202020;" alt="Summed Area Table">

<p align="center">
شکل شماره ۴
</p>

## آدابوست **[10]**
*آدابوست* الگوریتم یادگیری ماشینی است که می‌تواند همراه با سایر الگوریتم‌های یادگیری برای افزایش کارایی آن‌ها به کار رود. *آدابوست* از مجموع وزن‌دار خروجی این *الگوریتم‌های کلاس‌بندی*[^17] که از آن‌ها به عنوان *یادگیرنده‌ ضعیف*[^16] یاد می‌شود، *الگوریتم کلاس‌بندی* قوی‌تری را ایجاد کند که برای مثال در این مسأله می‌توان با درصد بالایی از اطمینان قاب‌های مختلف تصویر را به دسته‌های چهره و غیرچهره تقسیم کند.

به طور کلی الگوریتم‌های *[بوستینگ](http://en.wikipedia.org/wiki/Boosting_(meta-algorithm))*[^19] در گرد این سوال به وجود آمده‌اند که آیا با استفاده از چندین *یادگیرنده‌ی ضعیف* می‌توان به یک *یادگیرنده‌ی قوی* رسید؟ یک *یادگیرنده‌ی ضعیف* به این صورت تعریف می‌شود که فقط بتواند از حالت تصادفی عملکرد بهتری داشته باشد و یا به عبارت دیگر به حالت درست نزدیک‌تر باشد. در مقابل *یادگیرنده‌های قوی* به دسته‌ای از *الگوریتم‌های کلاس‌بندی* اطلاق می‌شود که همبستگی زیادی با حالت درست داشته باشند.

<img src="http://cesaserver.iust.ac.ir:7000/public.php?service=files&t=74066393dff6be818fac6f80ed23defb&download" style="width:448px;-webkit-border-radius:20px;-moz-border-radius: 20px;border-radius: 20px;  box-shadow: 0px 0px 7px 1px #202020;-webkit-box-shadow: 0px 0px 7px 1px #202020;-moz-box-shadow: 0px 0px 7px 1px #202020;" alt="Adaboost Algorithm" >

<p align="center">
شکل شماره ۵
</p>

در بازشناسی اشیا *مشخصه‌های هار* نقش به سزایی را ایفا می‌کنند. در تعریف *مشخصه‌های هار* از ویژگی‌های تصاویر دیجیتال است که قابلیت به دست آوردن مشخصات متفاوت تصویر را بدون نیاز به محاسبات زیاد به ما می‌دهد در حالی که مقادیر موجود در هر پیکسل نیاز به محاسبات زیاد و پیچیده‌ای برای بدست آوردن این مشخصات دارند.


<img src="http://cesaserver.iust.ac.ir:7000/public.php?service=files&t=9d591d7cca8e6fc0c007cbfdb36badd0&download" style="width:320px;-webkit-border-radius:20px;-moz-border-radius: 20px;border-radius: 20px;  box-shadow: 0px 0px 7px 1px #202020;-webkit-box-shadow: 0px 0px 7px 1px #202020;-moz-box-shadow: 0px 0px 7px 1px #202020;" alt="Haar Features" >
<p align="center">
شکل شماره ۶
</p>
<img src="http://cesaserver.iust.ac.ir:7000/public.php?service=files&t=b1c6a81d116af04ba1997d4fbfa2dff4&download" style="width:320px;-webkit-border-radius:20px;-moz-border-radius: 20px;border-radius: 20px;  box-shadow: 0px 0px 7px 1px #202020;-webkit-box-shadow: 0px 0px 7px 1px #202020;-moz-box-shadow: 0px 0px 7px 1px #202020;" alt="Used Haar Features" >
<p align="center">
شکل شماره ۷
</p>
لینهارت و همکاران در **[6]** علاوه بر مشخصات مورد استفاده توسط وایولا و جونز در **[2]** که به شکل مستطیل هستند مشخصاتی دیگر که زاویه‌ی ۴۵ درجه دارند را با وام‌گیری از کارهای پاپاجورجو در **[7]** و **[8]** به جزییات این کار اضافه کردند که

<img src="http://cesaserver.iust.ac.ir:7000/public.php?service=files&t=a27b248754ef6e9cd82b8ef51877869b&download" style="width:512px;-webkit-border-radius:20px;-moz-border-radius: 20px;border-radius: 20px;  box-shadow: 0px 0px 7px 1px #202020;-webkit-box-shadow: 0px 0px 7px 1px #202020;-moz-box-shadow: 0px 0px 7px 1px #202020;" alt="Extended Haar Features" >
<p align="center">
شکل شماره ۸
</p>
*آدابوست* از این جهت مورد استفاده قرار می‌گیرد که می‌توان ترتیب *یادگیرنده‌های ضعیف* را به گونه‌ای تغییر دهد تا خطا در نمونه‌های *کلاس‌بندی نشده*[^20] به حداقل برسد. وقتی قدرت اصلی آدابوست مشخص می‌شود که از زیاد بودن ابعاد در بسیاری از مسایل حوزه‌ی هوش مصنوعی صحبت کنیم. برای مثال همان طور که در الگوریتم ارایه شده توسط وایولا و جونر استفاده شده است در یک قاب با ابعاد ۲۴x۲۴ بیش از ۱۶۲هزار مشخصه‌ی هار وجود دارد که بسیار بیشتر از ابعاد قاب می‌باشد. بر خلاف سایر روش‌ها، *آدابوست* آن مشخصه‌هایی را انتخاب می‌کند که قابلیت پیش‌بینی بیشتری را در اختیار ما قرار می‌دهند. در یک تصویر درصد بسیار بالایی را قاب‌هایی تشکیل می‌دهند که شامل هیچ چهره‌ای نیستند پس اگر بتوان *الگوریتم کلاس‌بندی* را ساخت که قادر به تشخیص این قاب‌ها با استفاده از محاسبه‌ی پایین باشد، می‌توان مقدار زیادی از محاسبات کم کرد به این صورت که *آستانه‌*[^21] الگوریتم را به اندازه‌ای پایین می‌آوریم تا به میزان تشخیص ۱۰۰٪ برسیم ولی از آن‌جایی که *الگوریتم کلاس‌بندی* ما فقط از یک یا دو *مشخصه‌ی هار* استفاده می‌کند میزان خطای مثبت بالایی نیز در انتظار ما خواهد بود. به همین ترتیب و با استفاده از *مدل آبشاری* *الگوریتم کلاس‌بندی* که در مرحله‌ی اول آبشار وجود دارد ساده‌ترین و با کمترین میزان محاسبه خواهد بود و هر چه به مراحل بعدی آبشار می‌رویم این *الگوریتم*ها پیچیده‌تر می‌شوند و به مقدار بیشتری محاسبه نیاز دارند.


## مدل آبشاری کلاس‌بندی اشیا
در مدل آبشاری که در **[2]** مورد استفاده واقع شده ۳۸ مرحله وجود دارد و بیش از ۶۰۰۰ عدد از مشخصه‌های هار مورد استفاده قرار می‌گیرد که در آن هر مرحله نسبت به مرحله قبل پیچیده‌تر و از لحاظ محاسباتی سنگین‌تر خواهد بود. تعداد مشخصه‌هایی که در ۵ مرحله‌ی اول مورد آزمایش قرار می‌گیرد به ترتیب ۱، ۱۰، ۲۵، ۲۵ و ۵۰ هست. در بقیه‌ی لایه‌ها به ترتیب این تعداد افزایش می‌یابد تا مجموع آن به بیش از ۶۰۰۰ عدد می‌رسد.

<img src="http://cesaserver.iust.ac.ir:7000/public.php?service=files&t=41cdaf2fe1e09837254896d50c6379fd&download" style="width:512px;-webkit-border-radius:20px;-moz-border-radius: 20px;border-radius: 20px;  box-shadow: 0px 0px 7px 1px #202020;-webkit-box-shadow: 0px 0px 7px 1px #202020;-moz-box-shadow: 0px 0px 7px 1px #202020;" alt="Casecade Model Procedure" >
<p align="center">
شکل شماره ۹
</p>
همان‌طور که در تصویر بالا مشاهده می‌شود خروجی‌های مرحله‌ی اول در صورت موفق ظاهر شدن به مرحله‌ی دوم آبشار راه می‌یابند تا در این مرحله نیز بعضی از آنها که مشخصه‌های لازم را ندارند رد شوند. بدین ترتیب مقدار زیادی از تصاویر غیرچهره حذف شده و محاسبات بیشتر روی قاب‌هایی صورت می‌گیرد که شانس بیشتری برای حضور چهره در خود دارند.

# کار‌های آینده
در آینده در نظر داریم تا با اضافه کردن قسمت‌های زیر کارایی را در این مدل بهبود ببخشیم.

یکی از این قسمت‌ها می‌تواند چهره‌ی ارائه شده توسط سیستم حاضر را دریافت کرده و با مقایسه‌ی آن با مدل از چهره که توسط انسان ایجاد شده است، تائیدی باشد بر این‌که قاب ارائه شده شامل تصویر است و در صورتی که مشابهتی وجود نداشت. قاب را حذف کند.

نمونه‌ای از مدلی از چهره انسان در [شکل شماره ۲][#pic2] مشاهده می‌شود.

	
# مراجع
+ **[1]** D. A. Forsyth and J. Ponce, Computer Vision: A Modern Approach, 2nd ed. .
+ **[2]** P. Viola and M. Jones, “Rapid object detection using a boosted cascade of simple features,” Proc. 2001 IEEE Comput. Soc. Conf. Comput. Vis. Pattern Recognition. CVPR 2001, vol. 1, 2001.
+ **[3]** M.-H. Y. M.-H. Yang, D. J. Kriegman, and N. Ahuja, “Detecting faces in images: a survey,” IEEE Trans. Pattern Anal. Mach. Intell., vol. 24, no. 1, pp. 34–58, 2002.
+ **[4]** G. Yang and T. S. Huang, “Human Face Detection in Complex Background,” Pattern Recognition, vol. 27, no. 1, pp. 53-63, 1994.
+ **[5]** B. Scassellati,“Eye Finding via Face Detection for a Foevated, Active Vision System,” Proc. 15th Nat’l Conf. Artificial Intelligence, 1998.
+ **[6]** R. Lienhart, A. Kuranov, V. Pisarevsky, and M. R. L. T. Report, “Empirical Analysis of Detection Cascades of Boosted Classifiers for Rapid Object Detection,” 2002.
+ **[7]** A. Mohan, C. Papageorgiou, T. Poggio. Example-based object detection in images by components. IEEE Transactions on Pattern Analysis and Machine Intelligence, Vol. 23, No. 4, pp. 349 -361, April 2001.
+ **[8]** C. Papageorgiou, M. Oren, and T. Poggio. A general framework for Object Detection. In International Conference on Computer Vision, 1998.
+ **[9]** Summed Area Table, http://en.wikipedia.org/wiki/Summed_area_table
+ **[10]** Adaboost, http://en.wikipedia.org/wiki/AdaBoost

<!--

# پیوندهای مفید #
+ [کتابخانه اپن‌سی‌وی](http://opencv.org)
+ [تشخیص چهره انسان در اپن‌سی‌وی](http://docs.opencv.org/trunk/doc/py_tutorials/py_objdetect/py_face_detection/py_face_detection.html)
+ [اپن‌سی‌وی در پایتون](http://docs.opencv.org/trunk/doc/py_tutorials/py_tutorials.html)
+ [نصب اپن‌سی‌وی در ابونتو](https://help.ubuntu.com/community/OpenCV)
+ [شناسایی اجسام در تصاویر با اپن‌سی‌وی](http://note.sonots.com/SciSoftware/haartraining.html)
+ [مهم‌ترین مقاله در این زمینه](https://www.cs.cmu.edu/~efros/courses/LBMV07/Papers/viola-cvpr-01.pdf)
+ [بینایی کامپیوتری در جاوااسکریپت](http://inspirit.github.io/jsfeat/)
+ [تشخیص چهره در جاوااسکریپت ۱](http://inspirit.github.io/jsfeat/#haar)
+ [تشخیص چهره در جاوااسکریپت ۲](http://inspirit.github.io/jsfeat/#bbf)

-->

[^1]: Pose
[^2]: Image orientation.
[^3]: Face localization.
[^4]: Window.
[^5]: Face features detection.
[^6]: Knowledge-based.
[^7]: Feature invariant.
[^8]: Template matching.
[^9]: Appearance-based.
[^10]: Detection rate.
[^11]: False alarm.
[^12]: Positive alarm.
[^13]: Integral image.
[^14]: AdaBoost.
[^15]: Summed area table.
[^16]: Weak learner.
[^17]: classifier.
[^18]: Haar features.
[^19]: Boosing.
[^20]: misclassified.
[^21]: Threshold.
